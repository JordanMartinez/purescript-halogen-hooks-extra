module Halogen.Hooks.Extra.Hooks.UseQueries where
--   ( useQueries
--   , UseQueries
--   )
--   where
--
-- import Prelude
--
-- import Data.Foldable (traverse_)
-- import Data.Maybe (Maybe(..))
-- import Data.Newtype (class Newtype)
-- import Data.Tuple.Nested ((/\))
-- import Effect.Aff (Milliseconds, delay)
-- import Effect.Aff.Class (class MonadAff, liftAff)
-- import Effect.Class (liftEffect)
-- import Effect.Ref as Ref
-- import Halogen.Hooks (Hook, HookM, QueryToken, UseRef)
-- import Halogen.Hooks as Hooks
--
-- newtype UseQueries hooks = UseThrottle hooks
--
-- derive instance newtypeUseQueries :: Newtype (UseQueries hooks) _
--
-- useQueries
--   :: forall m
--    . Monad m
--   => QueryToken (VariantF)
--   -> SProxy sym
--   -> (a -> HookM m Unit)
--   -> Hook m (UseThrottle a) (a -> HookM m Unit)
-- useQueries ms fn = Hooks.wrap Hooks.do
--   _ /\ ref <- Hooks.useRef { running: false, val: Nothing }
--
--   let
--     throttleFn x = do
--       running <- liftEffect $
--         map (_.running) $ Ref.modify (_ { val = Just x }) ref
--
--       unless running do
--         void $ Hooks.fork do
--           liftAff $ delay ms
--           val <- liftEffect $
--             map (_.val) $ Ref.modify (_ { running = false}) ref
--           traverse_ fn val
--
--         liftEffect $
--           Ref.modify_ (_ { running = true }) ref
--
--   Hooks.pure throttleFn
